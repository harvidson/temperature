import React from 'react';
import { Formik } from 'formik';
import DatePicker from 'react-date-picker';
import moment from 'moment';
// import 'react-datepicker/dist/react-datepicker.css';
// import 'react-datepicker/dist/react-datepicker-cssmodules.css'

class NewIteration extends React.Component {
  constructor(props){
    super(props)

    this.state = {
      prompt: this.props.event.default_prompt || '',
      dueDate: new Date(),
      minWordCount: 0,
      isAnonymous: true,
      description: this.props.description || '',

    }

    this.handleInputChange = this.handleInputChange.bind(this);

    this.handlePromptChange = this.handlePromptChange.bind(this);
    this.handleDueDateChange = this.handleDueDateChange.bind(this);
    this.handleMinWordCountChange = this.handleMinWordCountChange.bind(this)
    this.handleIsAnonymousChange = this.handleIsAnonymousChange.bind(this)
    this.handleSubmit = this.handleSubmit.bind(this);


  }

handleInputChange(event) {
  const target = event.target;
  const value = target.type === 'checkbox' ? target.checked : target.value;
  const name = target.name;

  this.setState({
    [name]: value
  });
}

handlePromptChange(event) {
  this.setState({prompt: event.target.value});
}

handleDueDateChange(event) {
  this.setState({dueDate: event.target.value});
}

handleDueDateChange(date) {
  this.setState({dueDate: date});
}

handleMinWordCountChange(event) {
  this.setState({minWordCount: event.target.value});
}

handleIsAnonymousChange(event) {
  this.setState({isAnonymous: event.target.value});
}

handleSubmit(values) {
  // event.preventDefault();

  const newIteration = {
    prompt: this.state.prompt,
    dueDate: this.state.dueDate,
    minWordCount: this.state.minWordCount,
    isAnonymous: this.state.isAnonymous
  }
  console.log('iteration submitted!', newIteration);

    return fetch(`/api/events/${this.props.event.id}/iterations`, {
      method: 'post',
      body: JSON.stringify(newIteration),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      credentials: 'include'
    })
    .then((response) => {
      return response.json();
    })
}


  render(){
    const { event } = this.props
    console.log(event);
    return(
      <div className="mh4 pa4-l">
        <div className="tc">
          <h1 className="accent-orange f1-l f2 fw4">New Reflection </h1>
          <h2 className="accent-orange f2-l f3 fw4">{ event.title }</h2>
        </div>

        <Formik
          initialValues={{
            email: '',
            password: '',
            prompt: event.default_prompt || '',
            due_date: Date.now()
          }}
          validate={values => {
            let errors = {}
            if (!values.email) {
             errors.email = 'Required'
            } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
             errors.email = 'Invalid email address'
            }
            return errors
          }}
          onSubmit={(values, { setSubmitting,  setErrors, /* setValues and other goodies */ }) => {
            this.handleSubmit(values)
              .then(
                iteration => {
                  setSubmitting(false)
                  // do whatevs...
                  // props.updateUser(user)
                },
                errors => {
                  setSubmitting(false)
                  console.log(errors);
                  // Maybe transform your API's errors into the same shape as Formik's
                  // setErrors(transformMyApiErrors(errors))
                }
              )
          }}
          render={({ values, errors, touched, handleChange, handleBlur, handleSubmit, isSubmitting }) =>
            <form onSubmit={handleSubmit}>
              <div className="mt4">
                <div className="fw3 lh-copy f4 dark-gray db">
                  Series description</div>
                  <p>{ event.description }</p>
              </div>
              <div className="mt4">
                <label className="fw3 lh-copy f4 dark-gray db">
                  Reflection prompt
                  <textarea
                    className="mv2 bg-transparent w-100 measure db ba b--black-20 f5"
                    rows="3"
                    type="teaxtarea"
                    name="prompt"
                    value={ values.prompt }
                    onChange={ handleChange }/>
                </label>
              </div>
              <div className="mt4">
                <label className="fw3 lh-copy f4 dark-gray db">
                  Due date
                  <DatePicker
                    type="date"
                    showTimeSelect
                    dateFormat="LLL"
                    selected={this.state.dueDate}
                    // value={selected}
                    onChange={ this.handleInputChange }
                  />
                </label>
              </div>
              <input
                type="email"
                name="email"
                onChange={handleChange}
                onBlur={handleBlur}
                value={values.email}
              />
              {touched.email && errors.email && <div>{errors.email}</div>}
              <input
                type="password"
                name="password"
                onChange={handleChange}
                onBlur={handleBlur}
                value={values.password}
              />
              {touched.password && errors.password && <div>{errors.password}</div>}
              <div className="tc mt4">
                <button
                  className="f6 no-underline grow dib v-mid white ba ph3 pv2 mb3 action-button br1 link grow pointer"
                  type="submit"
                  disabled={isSubmitting}
                >
                  Submit
                </button>
              </div>
            </form>}
        />
        </div>

    )
  }
}

export default NewIteration
